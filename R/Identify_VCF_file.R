#' identify_VCF_file
#' 
#' Identifies a cancer cell lines contained in a vcf file based 
#' on the pattern (start & length) of all contained mutations/ variations.
#' 
#' \code{identify_vcf_file} parses the vcf file and predicts 
#' the identity of the sample
#' 
#' @param write_xls Create identification results additionally 
#' as xls file for easier reading
#' @param vcf_file Input vcf file. Only one sample column allowed.
#' @param output_file Path of the output file. If blank, 
#' autogenerated as name of input file plus '_uniquorn_ident.tab' suffix.
#' @param ref_gen Reference genome version. All training sets are 
#' associated with a reference genome version. Default: GRCH37
#' @param similarity_threshold Cl identification that surpass this 
#' percentage of training mutation weight (importance) are predicted 
#' as present in the sample. 
#' @param mutational_weight_inclusion_threshold Include only mutations 
#' with a weight of at least x. Range: 0.0 to 1.0. 1= unique to CL. 
#' ~0 = found in many CL samples. 
#' @param only_first_candidate Only the CL identifier with highest 
#' score is predicted to be present in the sample
#' @param minimum_matching_mutations The minimum amount of mutations that 
#' has to match between query and training sample for a positive prediction
#' @param distinct_mode Show training data for the commonly or separately 
#' normalized training sets. Options: TRUE/ FALSE
#' @param manual_identifier_bed_file Manually enter a vector of CL 
#' name(s) whose bed files should be created, independently from 
#' them passing the detection threshold
#' @param output_bed_file If BED files for IGV visualization should be 
#' created for the Cancer Cell lines that pass the threshold
#' @param verbose Print additional information
#' @import DBI WriteXLS RSQLite
#' @usage 
#' identify_vcf_file( 
#' vcf_file,
#' output_file = "",
#' ref_gen = "GRCH37",
#' similarity_threshold = 5.0,
#' minimum_matching_mutations = 4,
#' mutational_weight_inclusion_threshold = 1.0,
#' only_first_candidate = FALSE,
#' distinct_mode = TRUE,
#' write_xls = FALSE,
#' output_bed_file = FALSE,
#' manual_identifier_bed_file = "",
#' verbose = FALSE)
#' @examples 
#' HT29_vcf_file = system.file("extdata/HT29.vcf.gz", package="Uniquorn");
#' 
#' identification = identify_vcf_file( HT29_vcf_file )
#' @return R table with a statistic of the identification result
#' @export
identify_vcf_file = function(
    vcf_file,
    output_file = "",
    ref_gen = "GRCH37",
    similarity_threshold = 5.0,
    minimum_matching_mutations = 4,
    mutational_weight_inclusion_threshold = 1.0,
    only_first_candidate = FALSE,
    distinct_mode = TRUE,
    write_xls = FALSE,
    output_bed_file = FALSE,
    manual_identifier_bed_file = "",
    verbose = FALSE
    ){
  
  if ( verbose )  
    print( paste0("Assuming reference genome ", ref_gen) )
  
    ### pre processing
  
  if (verbose)
    print( paste0("Reading VCF file: ", vcf_file ) )
    
    vcf_fingerprint = parse_vcf_file( vcf_file )
    
    if ( output_file == ""  ){
    
        output_file = base::paste( vcf_file, "uniquorn_ident.tab", sep ="_")
    
    }else if ( base::dir.exists( output_file ) ){
    
        vcf_file_name = utils::tail( as.character( unlist( stringr::str_split( vcf_file, "/" ) ) ), 1 )
        output_file = base::paste( output_file, base::paste( 
            vcf_file_name, "uniquorn_ident.tab", sep ="_"), sep = "/") 
    
    }
    output_file_xls = stringr::str_replace( output_file, ".tab$", ".xls" ) 
    
    if ( verbose )
      print( "Finished reading the VCF file, loading database" )

    sim_list       = initiate_db_and_load_data( ref_gen = ref_gen, 
        distinct_mode = distinct_mode, request_table = "sim_list" )
    sim_list_stats = initiate_db_and_load_data( ref_gen = ref_gen, 
        distinct_mode = distinct_mode, request_table = "sim_list_stats" )
    
    contained_cls_original = sim_list_stats$CL
    
    if ( ( sum( grepl( "_COSMIC", sim_list_stats$CL ) ) + sum( grepl( "_CCLE", sim_list_stats$CL ) ) ) == 0 )
        
      if( verbose )
          warning("CCLE & CoSMIC CLP cancer cell line fingerprint NOT 
              found, defaulting to 60 CellMiner cancer cell lines! 
              It is strongly advised to add ~1900 CCLE & CoSMIC CLs, see readme."
        )

    sim_list = sim_list[ sim_list$Ref_Gen == ref_gen  ,]
    sim_list_stats = sim_list_stats[ sim_list_stats$Ref_Gen == ref_gen  ,]
    
    if (verbose)
        print( base::paste0( c("Found ", base::as.character( 
            base::length( unique(sim_list$CL) ) ), " many CLs for reference genome ", 
            ref_gen ), collapse = "" ) )
    
    if (verbose)
        print("Finished reading database, identifying CL")
    
    # filter for weights
    if ( mutational_weight_inclusion_threshold != 0.0  ){
    
      if (verbose)        
        print( base::paste0( c("Adjusted mutational inclusion weight, 
            only using mutations that are have a weight higher than ", 
            as.character(mutational_weight_inclusion_threshold)), collapse="") )
        
        sim_list = sim_list[ base::as.double(sim_list$Weight) >= 
            as.double( mutational_weight_inclusion_threshold) ,  ]
        sum_vec = rep(1, dim(sim_list)[1])
        
        sim_list_stats = stats::aggregate( as.double( sum_vec ), 
            by = list( sim_list$CL), FUN = sum  )
        
        all_weights = stats::aggregate( sim_list$Weight, by = list(sim_list$CL), FUN = sum)
        mapping = match( sim_list_stats$Group.1, all_weights$Group.1 )
        sim_list_stats = cbind( sim_list_stats, all_weights$x[mapping] )
        
        colnames( sim_list_stats ) = c("CL","Count", "All_weights")
        sim_list_stats$All_weights = round(sim_list_stats$All_weights,1)
       
        if (verbose)
         print( paste0( c("Found ", as.character( dim(sim_list)[1] ), 
            " many mutations with mutational weight of at least ", 
            mutational_weight_inclusion_threshold), collapse="")  )
    }
    
    dif = length(contained_cls_original) - 
        length (sim_list_stats$CL)
    dif_cls = contained_cls_original[
        which(!(contained_cls_original %in% sim_list_stats$CL))
    ]
    
    if ( (dif != 0) & verbose )
        warning(paste0(c(
            as.character(dif),
            " CLs have no mutations for the chosen weight 
            and cannot be identified: ",
            paste0(c(dif_cls), collapse = ", ")
            , " Probably they are too closely simlar to other training CLs"),
            collapse=""
        ))
    
    list_of_cls       = unique( sim_list$CL )
    nr_cls            = length( list_of_cls  ) # amount cls
    
    candidate_hits_abs_all = rep(0, nr_cls)
    names(candidate_hits_abs_all) = list_of_cls
    
    found_mut_mapping = which( sim_list$Fingerprint %in% as.character(unlist(vcf_fingerprint)) ) # mapping
        
    candidate_hits_abs      = rep( 0.0, nr_cls )
    candidate_hits_abs_all  = rep( 0.0, nr_cls )
    candidate_hits_rel      = rep( 0.0, nr_cls )
    
    cl_weight               = rep( 0.0, nr_cls )
    cl_weight_rel           = rep( 0.0, nr_cls )
    all_weighted            = rep( 0.0, nr_cls )
    
    passed_threshold_vec    = rep( FALSE, nr_cls )
    
    res_cl_weighted         = rep( 0.0, nr_cls )
    res_res_cl_weighted     = rep( 0.0, nr_cls )
    stats_all_weight        = rep( 0.0, nr_cls )
    
    cl_absolute_mutation_hits = rep( 0.0, nr_cls )
        
    if ( length( found_mut_mapping ) != 0){
        
        ### unweighted scores
        
        candidate_hits_abs = stats::aggregate( 
            rep(1, length(found_mut_mapping)),
            by = list(sim_list$CL[ found_mut_mapping ]), 
            FUN = sum
        )
        
        candidate_hits_abs_all[ which( list_of_cls %in% candidate_hits_abs$Group.1) ] = 
            as.integer( candidate_hits_abs$x[ match( 
                list_of_cls, 
                candidate_hits_abs$Group.1, 
                nomatch = 0 ) ] )
        
        cl_match_stats    = match( list_of_cls, sim_list_stats$CL, nomatch = 0 ) # mapping
        candidate_hits_rel = round( 
            candidate_hits_abs_all / sim_list_stats$Count[ cl_match_stats ] * 100,
        1 ) 
        
        ### weighted scores
    
    
        # threshold non weighted

        passed_threshold_vec[ 
          ( candidate_hits_abs_all >= minimum_matching_mutations ) & 
          ( candidate_hits_rel     >= similarity_threshold )
        ] = TRUE
        passed_threshold_weighted = rep( "", nr_cls )
        
        # aggregate over weights & CL identifier
        
        aggregation = stats::aggregate(
            x  = as.double( sim_list$Weight[ found_mut_mapping  ] ),
            by = list( as.character( sim_list$CL[ found_mut_mapping ] )  ),
            FUN = sum
        )
        
        weight_all = sim_list_stats$All_weights[ 
          match( aggregation$Group.1, sim_list_stats$CL )
        ]
        mapping_to_cls = match( 
          list_of_cls,
          aggregation$Group.1,
          nomatch = 0
        )
        
        names( res_cl_weighted ) = list_of_cls
        res_cl_weighted[ names( res_cl_weighted ) %in% aggregation$Group.1  ] = 
          aggregation$x[ mapping_to_cls ]
        stats_all_weight = sim_list_stats$All_weights[ 
          match( list_of_cls, sim_list_stats$CL  )
        ]
        
        res_res_cl_weighted = round( as.double(res_cl_weighted  ) / 
                                       stats_all_weight * 100, 1 )
        res_cl_weighted = round(res_cl_weighted, 0)
    
        cl_absolute_mutation_hits = sim_list_stats$Count[ cl_match_stats ]
    }
    
    # treshold
    
    passed_threshold_weighted = rep( FALSE, nr_cls )
    passed_threshold_weighted[ 
        ( candidate_hits_abs_all >= minimum_matching_mutations ) & 
        ( candidate_hits_rel     >= similarity_threshold ) & 
        ( res_res_cl_weighted    >= similarity_threshold ) 
    ] = TRUE
    
    output_cl_names = stringr::str_replace( list_of_cls, pattern = "_CCLE|_COSMIC|_CELLMINER|_CUSTOM", replacement = "" )
    panel_vec = rep("", length( output_cl_names ))
    panel_vec[ stringr::str_detect( list_of_cls, "_CCLE" ) ] = "CCLE"
    panel_vec[ stringr::str_detect( list_of_cls, "_COSMIC" ) ] = "COSMIC"
    panel_vec[ stringr::str_detect( list_of_cls, "_CELLMINER" ) ] = "CELLMINER"
    panel_vec[ stringr::str_detect( list_of_cls, "_CUSTOM" ) ] = "CUSTOM"
    
    res_table = data.frame(
        "CL"                       = output_cl_names,
        "CL_source"                = panel_vec,
        "Found_muts_abs"           = as.character( candidate_hits_abs_all ),
        "Count_mutations_abs"      = as.character(  cl_absolute_mutation_hits ),
        "Found_muts_rel"           = as.character(  candidate_hits_rel ),
        "Found_muts_weighted"      = as.character( res_cl_weighted ),
        "Count_mutations_weighted" = as.character( round( stats_all_weight, 0 ) ),
        "Found_muts_weighted_rel"  = as.character( res_res_cl_weighted ),
        "Passed_threshold"         = as.character( passed_threshold_weighted )
    )
    
    res_table = res_table[ order( as.double( as.character( res_table$Found_muts_weighted_rel) ), decreasing = TRUE),  ]
    
    
    add_missing_cls = function( res_table, dif_cls ){
        
        for (cl in dif_cls){
            
            res_table = data.frame(
                "CL"                       = c( 
                    as.character(res_table$CL), 
                    as.character(cl)),
                "CL_source"                = c( 
                    as.character( res_table$CL_source),
                    utils::tail(unlist(str_split(cl,"_")),1
                    )),
                "Found_muts_abs"           = c( 
                    as.character( res_table$Found_muts_abs ),
                    as.character( "0" )),
                "Count_mutations_abs"      = c( 
                    as.character( res_table$Count_mutations_abs),
                    as.character( "0" )),
                "Found_muts_rel"           = c( 
                    as.character( res_table$Found_muts_rel),
                    as.character( "0" )),
                "Found_muts_weighted"      = c( 
                    as.character( res_table$Found_muts_weighted),
                    as.character( "0" )),
                "Count_mutations_weighted" = c( 
                    as.character( res_table$Count_mutations_weighted),
                    as.character( "0" )),
                "Found_muts_weighted_rel"  = c( 
                    as.character( res_table$Found_muts_weighted_rel),
                    as.character( "0" )),
                "Passed_threshold"         = c( 
                    as.character( res_table$Passed_threshold ),
                    as.character( "FALSE" ))
            )
        }
        
        return( res_table )
    }
    res_table = add_missing_cls( res_table, dif_cls )
    
    if (only_first_candidate)
        
      res_table$Passed_threshold[ seq(2, length(res_table$Passed_threshold)) ] = FALSE
    
    if ( verbose )
        
      print( paste0( "Candidate(s): ", paste0( ( unique( 
            as.character( res_table$CL )[ res_table$Passed_threshold == TRUE  ]) ), 
            collapse = "," ) )  )
    
    if( verbose )
        
      print( paste0("Storing information in table: ",output_file ) )
    
    utils::write.table( res_table, output_file, sep ="\t", row.names = FALSE, quote = FALSE  )
    
    if (output_bed_file & ( sum( as.logical(res_table$Passed_threshold) ) > 0 ))
         create_bed_file( 
             sim_list, 
             vcf_fingerprint, 
             res_table, 
             output_file, 
             ref_gen, 
             manual_identifier_bed_file
        )

    
    if ( write_xls )

        WriteXLS::WriteXLS( x = res_table, path.expand( output_file_xls ), row.names = FALSE)
    
    return( res_table )
}

